{{define "httpserver"}}// Generated by github.com/hypermusk/hypermusk
// DO NOT EDIT
{{$pkg := .}}
package {{.Name}}httpimpl

import ({{range .ServerImports}}
	"{{.}}"{{end}}
)

var _ = time.Sunday
var _ = base64.StdEncoding

const StreamHTTPHeaderFieldName = "X-HyperMuskStreamParams"

type CodeError interface {
	Code() string
}

type SerializableError struct {
	Code    string
	Message string
	Reason  error
}

func (s *SerializableError) Error() string {
	return s.Message
}

func NewError(err error) (r error) {
	se := &SerializableError{Message:err.Error()}
	ce, yes := err.(CodeError)
	if yes {
		se.Code = ce.Code()
	}
	se.Reason = err
	r = se
	return
}

func AddToMux(prefix string, mux *http.ServeMux) {
	{{range .Interfaces}}{{$interface := .}}{{range .Methods}}{{if .ConstructorForInterface}}{{else}}
	mux.HandleFunc(prefix+"/{{$interface.Name}}/{{.Name}}.json", {{$interface.Name}}_{{.Name}}){{end}}{{end}}{{end}}
	return
}
{{range .Interfaces}}{{$interface := .}}
{{with .Constructor}}{{else}}
var {{$interface.Name | downcase}} {{$pkg.Name}}.{{$interface.Name}} = {{$pkg.ImplPkg | dotlastname}}.Default{{$interface.Name}}{{end}}

type {{$interface.Name}}Data struct {
{{with .Constructor}}{{range .Method.Params}}	{{.Name | title}} {{.FullGoTypeName}}
{{end}}{{end}}}

{{range .Methods}}{{if .ConstructorForInterface}}{{else}}{{$method := .}}
type {{$interface.Name}}_{{$method.Name}}_Params struct {
{{with $interface.Constructor}}	This   {{$interface.Name}}Data
{{end}}	Params struct {
{{range .Params}}		{{.Name | title}} {{.FullGoTypeName}}
{{end}}	}
}

type {{$interface.Name}}_{{$method.Name}}_Results struct {
{{range .Results}}	{{.Name | title}} {{.FullGoTypeName}}
{{end}}
}

func {{$interface.Name}}_{{$method.Name}}(w http.ResponseWriter, r *http.Request) {
	startAt := time.Now()
	log.Printf("Started %s \"%s\" for %s at %s\n", r.Method, r.RequestURI, r.RemoteAddr, startAt.String())
	defer func() {
		spent := time.Now().Sub(startAt) / time.Millisecond
		log.Printf("Completed \"%s\" in %d ms\n\n", r.RequestURI, spent)
	}()

	w.Header().Add("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept")
	w.Header().Add("Access-Control-Allow-Origin", "*")
	w.Header().Set("Content-Type", "application/json; charset=utf-8")

	var body io.Reader
{{if $method.IsStreamInput}}
	body = base64.NewDecoder(base64.StdEncoding, strings.NewReader(r.Header.Get(StreamHTTPHeaderFieldName)))
{{else}}
	jsonpCallback := r.URL.Query().Get("callback")
	if  jsonpCallback != "" {
		body = strings.NewReader(r.URL.Query().Get("data"))
		io.WriteString(w, jsonpCallback + "(")
		defer io.WriteString(w, ")")
	} else {
		if r.Body == nil {
			panic("no body")
		}
		body = r.Body
	}
{{end}}
	defer r.Body.Close()

	var p {{$interface.Name}}_{{$method.Name}}_Params

	dec := json.NewDecoder(body)
	err := dec.Decode(&p)
	var result {{$interface.Name}}_{{$method.Name}}_Results
	var mayGzipWriter io.Writer = w

	enc := json.NewEncoder(mayGzipWriter)
	if err != nil {
		result.Err = NewError(err)
		enc.Encode(result)
		return
	}
{{if $interface.Constructor}}
	s, err := {{$interface.Constructor.FromInterface.Name | downcase }}.{{$interface.Constructor.Method.Name}}({{$interface.Constructor.Method.ParamsForGoServerConstructorFunction}})
{{else}}
	s := {{$interface.Name | downcase }}
{{end}}
	if err != nil {
		result.Err = NewError(err)
		enc.Encode(result)
		return
	}
	{{$method.ResultsForGoServerFunction "result"}} = s.{{$method.Name}}({{$method.ParamsForGoServerFunction}}{{if $method.IsStreamInput}}, r.Body{{end}})
	if result.Err != nil {
		result.Err = NewError(result.Err)
	}
	err = enc.Encode(result)
	if err != nil {
		panic(err)
	}
	return
}
{{end}}{{end}}

{{end}}

{{end}}
